// Written by DJ Harrigan for Element14 Presents (December 2020)
// The following replicates the behavior of the split-flap countdown timer found in The Swan as seen on the show LOST
// No License provided

#include "USBHost_t36.h"
#include "TeensyStep.h"
#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>

#define SDCARD_CS_PIN    BUILTIN_SDCARD
#define SDCARD_MOSI_PIN  11  // not actually used
#define SDCARD_SCK_PIN   13  // not actually used

#define PIN_SENSOR_A 28
#define PIN_SENSOR_B 29
#define PIN_SENSOR_C 30
#define PIN_SENSOR_D 31
#define PIN_SENSOR_E 32
#define PIN_DRIVER_STEP_A 33
#define PIN_DRIVER_STEP_B 34
#define PIN_DRIVER_STEP_C 35
#define PIN_DRIVER_STEP_D 36
#define PIN_DRIVER_STEP_E 37
#define PIN_DRIVER_DIR_ALL 38 // DIR pins are tied (high/low) since the wheels can only mechanical move in one direction

#define USBBAUD 9600
uint32_t baud = USBBAUD;
uint32_t format = USBHOST_SERIAL_8N1;
USBHost myusb;
USBHub hub1(myusb);
USBHub hub2(myusb);
USBHIDParser hid1(myusb);
USBHIDParser hid2(myusb);
USBHIDParser hid3(myusb);
USBSerial userial(myusb);

USBDriver *drivers[] = {&hub1, &hub2, &hid1, &hid2, &hid3, &userial};
#define CNT_DEVICES (sizeof(drivers)/sizeof(drivers[0]))
const char * driver_names[CNT_DEVICES] = {"Hub1", "Hub2",  "HID1", "HID2", "HID3", "USERIAL1" };
bool driver_active[CNT_DEVICES] = {false, false, false, false};

AudioPlaySdWav           playWav1;
AudioOutputAnalog      audioOutput;
AudioConnection          patchCord1(playWav1, 0, audioOutput, 0);
AudioConnection          patchCord2(playWav1, 1, audioOutput, 1);

Stepper motorA(PIN_DRIVER_STEP_A, PIN_DRIVER_DIR_ALL);
Stepper motorB(PIN_DRIVER_STEP_B, PIN_DRIVER_DIR_ALL);
Stepper motorC(PIN_DRIVER_STEP_C, PIN_DRIVER_DIR_ALL);
Stepper motorD(PIN_DRIVER_STEP_D, PIN_DRIVER_DIR_ALL);
Stepper motorE(PIN_DRIVER_STEP_E, PIN_DRIVER_DIR_ALL);
StepControl controller;    // Use default settings
// Default parameters are
// Speed:          800 steps/s
// Acceleration:  2500 steps/s^2

const int stepsPerArc = 40; // How many steps to move to the next flap
const int timerLength = 6480; // 108 minutes x 60 seconds = 6480
int currentTimerCount = timerLength;
const int maxSpeed = 1000;
const int maxAccel = 4000;

String theNumbers = "4 8 15 16 23 42"; // the space characters are necessary
String inputString = "";
char inputChars[8];
String timerMinutesString = "000";
String timerSecondsString = "00";
String fail = "SYSTEM FAILURE";

boolean systemCritical = false; // Flag if we've reached the four minute mark
boolean systemFailure = false; // Flag if we've reached the one minute mark (show hieroglyphs)
boolean systemCalibrated = false;
boolean sequenceEntered = false;

// wheel A is the rightmost
int wheelADefaultIdx = 0; // each wheel isn't assembled in a known position, so its position somewhat random
int wheelBDefaultIdx  = 0;
int wheelCDefaultIdx  = 0;
int wheelDDefaultIdx  = 0;
int wheelEDefaultIdx  = 0;
int wheelACurIdx = 9; // each wheel isn't assembled in a known position, so its position somewhat random
int wheelBCurIdx  = 9;
int wheelCCurIdx  = 9;
int wheelDCurIdx  = 9;
int wheelECurIdx  = 9;
int wheelPositions[] = {wheelACurIdx, wheelBCurIdx, wheelCCurIdx, wheelDCurIdx, wheelECurIdx};
boolean sensorAState = false;
boolean sensorBState = false;
boolean sensorCState = false;
boolean sensorDState = false;
boolean sensorEState = false;

// the wheel is physically arranged as 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19
// 10= Blank 11=Cloth, 12=Spiral, 13=Feather, 14=Bird, 15=Stick, 16=Staple, 17=Man, 18=Bread, 19=Hand,
int symbolPattern[] = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19};

unsigned long currentSystemTime = 0;
unsigned long lastSystemTime = 0;
unsigned long oneSecond = 1000; // milliseconds

void setup() {

  Serial.begin(9600);

  pinMode(PIN_SENSOR_A, INPUT_PULLUP);
  pinMode(PIN_SENSOR_B, INPUT_PULLUP);
  pinMode(PIN_SENSOR_C, INPUT_PULLUP);
  pinMode(PIN_SENSOR_D, INPUT_PULLUP);
  pinMode(PIN_SENSOR_E, INPUT_PULLUP);
  pinMode(16, OUTPUT);
  digitalWrite(16, LOW);

  AudioMemory(16);
  SPI.setMOSI(SDCARD_MOSI_PIN);
    SPI.setSCK(SDCARD_SCK_PIN);
    if (!(SD.begin(SDCARD_CS_PIN))) {
      // stop here, but print a message repetitively
      while (1) {
        Serial.println("Unable to access the SD card");
        delay(500);
      }
    }

    motorA
      .setMaxSpeed(maxSpeed)
      .setAcceleration(maxAccel);
    motorB
      .setMaxSpeed(maxSpeed)
      .setAcceleration(maxAccel);
    motorC
      .setMaxSpeed(maxSpeed)
      .setAcceleration(maxAccel);
    motorD
      .setMaxSpeed(maxSpeed)
      .setAcceleration(maxAccel);
    motorE
      .setMaxSpeed(maxSpeed)
      .setAcceleration(maxAccel);
    //calibrateSystem();
    //for (int ii = 0; ii < 5; ii++) wheelPositions[ii] = 9;
    writeDisplay(10, 10, 10, 10, 10);
    delay(1000);
    Serial.println("SYSTEM CALIBRATED");
    writeDisplay(1, 0, 8, 0, 0); // calling writeDisplay too quickly causes irregular behavior and likely generates RF noise that messes with USB
    delay(1000);
    myusb.begin();

} // ******************************** END SETUP ********************************

void loop() {

  myusb.Task();
  initUSBDevices();

  sequenceEntered = getInput();

  if (systemCritical && sequenceEntered){ // You may only execute the sequence once 4 minutes or less remain
    testInput();
  }

  currentSystemTime = millis();

  if (currentSystemTime - lastSystemTime >= oneSecond){
    currentTimerCount--;
    updateDisplay(systemCritical, systemFailure);

    if (currentTimerCount <= 240 && systemCritical == false){
      systemCritical = true;
      Serial.println("SYSTEM CRITICAL");
      playSFX();
    }

    if (currentTimerCount <= 60 && systemFailure == false){
      systemFailure = true;
      // write "SYSTEM FAILURE" 100 times
      for (int ii = 0; ii < 100; ii++){
        //userial.write("SYSTEM FAILURE");
        Serial.println("SYSTEM FAILURE");
      }
    }

    lastSystemTime = currentSystemTime;

  }

} // ******************************** END MAIN LOOP ********************************
/* // Sensors are unused for now
void checkSensors(){
  sensorAState = digitalRead(PIN_SENSOR_A);
  sensorBState = digitalRead(PIN_SENSOR_B);
  sensorCState = digitalRead(PIN_SENSOR_C);
  sensorDState = digitalRead(PIN_SENSOR_D);
  sensorEState = digitalRead(PIN_SENSOR_E);
  Serial.print("Sensor A = ");Serial.println(sensorAState);
  Serial.print("Sensor B = ");Serial.println(sensorBState);
  Serial.print("Sensor C = ");Serial.println(sensorCState);
  Serial.print("Sensor D = ");Serial.println(sensorDState);
  Serial.print("Sensor E = ");Serial.println(sensorEState);

    if (!sensorAState) { // terrible code for now :)
      motorA.setPosition(0);
    }
    if (!sensorBState) {
      motorB.setPosition(0);
    }
    if (!sensorCState) {
      motorC.setPosition(0);
    }
    if (!sensorDState) {
      motorD.setPosition(0);
    }
    if (!sensorEState) {
      motorE.setPosition(0);
    }
}
*/
boolean getInput(){
  // read characters in from terminal
  while (userial.available()) {
    char inChar = userial.read();
    userial.write(inChar); // echo it
    //Serial.write(inChar);
    if (inChar == 'x') {
      systemCalibrated = false;
      calibrateSystem();
      break;
    }
    if (inChar == '\r') {
      //inputString = "";
      return true;
    } else {
      inputString += inChar;
    }
  }
  return false;

}

void testInput(){

  if (inputString.equals(theNumbers)) systemReset(); // no penalty for entering something wrong since it's not a puzzle!
  inputString = ""; // clear user input

}

void systemReset(){
  // stop sound effects, clear flags, reset timer, and set display to (108:00)
  Serial.println("SYSTEM STABLE");
  if (playWav1.isPlaying())playWav1.stop();
  systemCritical = false;
  systemFailure = false;
  currentTimerCount = timerLength;
  writeDisplay(1, 0, 8, 0, 0);
  delay(2000);
}

// write to an individual wheel using absolute positioning assuming display has been calbrated to show all zeroes
void writeWheel(int whichWheel, int whichSymbol){

  int positionDelta = 0;
  int curTempIdx = wheelPositions[whichWheel];
  while (symbolPattern[curTempIdx] != whichSymbol){ // determine distance to desired character if not already shown
    curTempIdx++;
    positionDelta++;
    if (curTempIdx > 19){
      curTempIdx = 0;
    }
  }

  int stepsToMove = 0;

  if (positionDelta){

    stepsToMove = -stepsPerArc * positionDelta;
    wheelPositions[whichWheel] = curTempIdx;

  } else if (positionDelta == 0){

    //Serial.print(" NO CHANGE");

  }

  switch (whichWheel){
    case 0: // A
        motorA.setTargetRel(stepsToMove);
    break;
    case 1: // B
        motorB.setTargetRel(stepsToMove);
    break;
    case 2: // C
        motorC.setTargetRel(stepsToMove);
    break;
    case 3: // D
        motorD.setTargetRel(stepsToMove);
    break;
    case 4: // E
        motorE.setTargetRel(stepsToMove);
    break;
  }
  //controller.moveAsync(motorA, motorB, motorC, motorD, motorE);

}

void writeDisplay(int mHundreds, int mTens, int mOnes, int sTens, int sOnes){ //m minutes, s seconds

  writeWheel(4, mHundreds); // wheel E
  writeWheel(3, mTens);
  writeWheel(2, mOnes);
  writeWheel(1, sTens);
  writeWheel(0, sOnes); // wheel A
  controller.move(motorA, motorB, motorC, motorD, motorE); //blocking movement for now...

}

void calibrateSystem(){
  // move each display to its index at symbol '0' (which is index 9)
  Serial.println("SYSTEM CALIBRATION REQUIRED");
  while(!systemCalibrated){

    while (Serial.available()) {
    char inChar = Serial.read();
     switch (inChar){
      case 'a':
        motorA.setTargetRel(-stepsPerArc);
        controller.moveAsync(motorA);
      break;
      case 'b':
        motorB.setTargetRel(-stepsPerArc);
        controller.moveAsync(motorB);
      break;
      case 'c':
        motorC.setTargetRel(-stepsPerArc);
        controller.moveAsync(motorC);
      break;
      case 'd':
        motorD.setTargetRel(-stepsPerArc);
        controller.moveAsync(motorD);
      break;
      case 'e':
        motorE.setTargetRel(-stepsPerArc);
        controller.moveAsync(motorE);
      break;
      case 'A': // move faster
        motorA.setTargetRel(-stepsPerArc*5);
        controller.moveAsync(motorA);
      break;
      case 'B':
        motorB.setTargetRel(-stepsPerArc*5);
        controller.moveAsync(motorB);
      break;
      case 'C':
        motorC.setTargetRel(-stepsPerArc*5);
        controller.moveAsync(motorC);
      break;
      case 'D':
        motorD.setTargetRel(-stepsPerArc*5);
        controller.moveAsync(motorD);
      break;
      case 'E':
        motorE.setTargetRel(-stepsPerArc*5);
        controller.moveAsync(motorE);
      break;
      case 'x':
        systemCalibrated = true;
        for (int ii = 0; ii < 5; ii++) wheelPositions[ii] = 9; // make sure wheel states are tracked!
      break;
      case 'r': // reset
        writeDisplay(1, 0, 8, 0, 0); // if this is the first instance of write display, it goes backwards???
      break;
      case '?': // hieroglyphs
        writeDisplay(11, 12, 13, 14, 15);
      break;
      case ' ':
        writeDisplay(10, 10, 10, 10, 10); // blank
      break;
      case '*':
        // placeholder
      break;
      case '!': // freak out!
      while (true){
        writeDisplay(random(19), random(19), random(19), random(19), random(19)); // blank
        delay(100);
        }
      break;
      }
    }
  }

}

void updateDisplay(boolean displaySeconds, boolean thingsAreBad){
  // actually count down the wheels, however seconds are only actively shown when time < 240 seconds
  // minutes wheels show hundreds, tens, and ones
  // if count < 240, show seconds
  // if count < 60 show hieroglyphs
  if (!thingsAreBad){ // only bother calculating if systemFailure is false
    int minutes = currentTimerCount / 60;
    int seconds = currentTimerCount % 60;
    String minutesString = String(minutes);
    String secondsString = String(seconds);
    int mHundreds, mTens, mOnes, sTens, sOnes;

    if (minutes >= 100){
    timerMinutesString.setCharAt(0, minutesString.charAt(0));
    timerMinutesString.setCharAt(1, minutesString.charAt(1));
    timerMinutesString.setCharAt(2, minutesString.charAt(2));
    }
    if (minutes < 100){
    timerMinutesString.setCharAt(0, '0');
    timerMinutesString.setCharAt(1, minutesString.charAt(0));
    timerMinutesString.setCharAt(2, minutesString.charAt(1));
    }
    if (minutes < 10){
    timerMinutesString.setCharAt(0, '0');
    timerMinutesString.setCharAt(1, '0');
    timerMinutesString.setCharAt(2, minutesString.charAt(0));
    }

    if (seconds < 10){
      timerSecondsString.setCharAt(0, '0');
      timerSecondsString.setCharAt(1, secondsString.charAt(0));
    } else{
      timerSecondsString.setCharAt(0, secondsString.charAt(0));
      timerSecondsString.setCharAt(1, secondsString.charAt(1));
    }

    mHundreds = int(timerMinutesString.charAt(0)) - 48; // ASCII DEC value to regular numbers
    mTens = int(timerMinutesString.charAt(1)) - 48;
    mOnes = int(timerMinutesString.charAt(2)) - 48;
    sTens = int(timerSecondsString.charAt(0)) - 48;
    sOnes = int(timerSecondsString.charAt(1)) - 48;
    Serial.print(mHundreds); Serial.print(mTens); Serial.print(mOnes); Serial.print(':');Serial.print(sTens); Serial.println(sOnes);
    if (displaySeconds){
      writeDisplay(mHundreds, mTens, mOnes, sTens, sOnes);
    } else{
      writeDisplay(mHundreds, mTens, mOnes, 0, 0);
    }
  } else {
    writeDisplay(11, 12, 13, 14, 15); // hieroglyphs
  }

}

void playSFX(){
  //play wave file of beeps and "system failure" noise
  playWav1.play("SWAN.WAV");

  // A brief delay for the library read WAV info
  delay(5);
}

void initUSBDevices(){ // copied and pasted from the Serial Test example in USBHost

  for (uint8_t i = 0; i < CNT_DEVICES; i++) {
    if (*drivers[i] != driver_active[i]) {
      if (driver_active[i]) {
        Serial.printf("*** Device %s - disconnected ***\n", driver_names[i]);
        driver_active[i] = false;
      } else {
        Serial.printf("*** Device %s %x:%x - connected ***\n", driver_names[i], drivers[i]->idVendor(), drivers[i]->idProduct());
        driver_active[i] = true;

        const uint8_t *psz = drivers[i]->manufacturer();
        if (psz && *psz) Serial.printf("  manufacturer: %s\n", psz);
        psz = drivers[i]->product();
        if (psz && *psz) Serial.printf("  product: %s\n", psz);
        psz = drivers[i]->serialNumber();
        if (psz && *psz) Serial.printf("  Serial: %s\n", psz);

        // If this is a new Serial device.
        if (drivers[i] == &userial) {
          // Lets try first outputting something to our USerial to see if it will go out...
          Serial.println("Testing userial found");
          userial.begin(USBBAUD);
          Serial.println("usbserial found");
        }
      }
    }
  }

}